import InterfaceGenerator from "../src/InterfaceGenerator";
import fs from "fs";

jest.mock("fs"); // Mock the file system to prevent actual file writes

describe("InterfaceGenerator", () => {
  let generator: InterfaceGenerator;

  beforeEach(() => {
    // Setup a new instance before each test
    generator = new InterfaceGenerator("IPerson", "./output", false);
  });

  afterEach(() => {
    jest.clearAllMocks(); // Clear any previous mocks
  });

  it("should add JSON variations correctly", () => {
    const jsonVariation = { name: "John", age: 30 };
    generator.addJsonVariation(jsonVariation);
    expect(generator["jsonVariations"]).toHaveLength(1);
    expect(generator["jsonVariations"][0]).toEqual(jsonVariation);
  });

  it("should merge JSON variations correctly", () => {
    const variation1 = {
      name: "John",
      age: 30,
      birthplace: {
        city: "New York City",
        state: "NY",
      },
      stats: [{ year: 2020, goals: 10 }],
    };

    const variation2 = {
      name: "Sarah",
      age: 20,
      birthplace: {
        city: "Toronto",
        country: "Canada",
      },
      stats: [{ year: 2020, assists: 5 }],
    };

    const merged = generator["mergeJsonVariations"]([variation1, variation2]);

    expect(merged).toEqual({
      name: "John",
      age: 30,
      birthplace: {
        city: "New York City",
        "state?": "NY",
        "country?": "Canada",
      },
      stats: [
        {
          year: 2020,
          "goals?": 10,
          "assists?": 5,
        },
      ],
    });
  });

  it("should handle empty arrays correctly in mergeJsonVariations", () => {
    const variation1 = {
      name: "John",
      pears: [],
    };

    const variation2 = {
      name: "Sarah",
      apples: 10,
    };

    const merged = generator["mergeJsonVariations"]([variation1, variation2]);

    expect(merged).toEqual({
      name: "John",
      "pears?": "undefined[]",
      "apples?": 10,
    });
  });

  it("should generate a TypeScript interface from data", () => {
    const data = {
      name: "John",
      age: 30,
      birthplace: {
        city: "New York",
        state: "NY",
      },
    };

    generator["generateInterfaceFromData"](data, "IPerson");

    expect(generator["accumulatedInterfaces"]).toContain("export interface IPerson {");
    expect(generator["accumulatedInterfaces"]).toContain("name: string;");
    expect(generator["accumulatedInterfaces"]).toContain("age: number;");
    expect(generator["accumulatedInterfaces"]).toContain("birthplace: IPerson_birthplace;");
  });

  it("should generate nested interfaces for objects", () => {
    const data = {
      name: "John",
      birthplace: {
        city: "New York",
        state: "NY",
      },
    };

    generator["generateInterfaceFromData"](data, "IPerson");

    expect(generator["accumulatedInterfaces"]).toContain("export interface IPerson {");
    expect(generator["accumulatedInterfaces"]).toContain("export interface IPerson_birthplace {");
    expect(generator["accumulatedInterfaces"]).toContain("city: string;");
    expect(generator["accumulatedInterfaces"]).toContain("state: string;");
  });

  it("should write interfaces to a file", () => {
    const mockWriteFileSync = jest.spyOn(fs, "writeFileSync");
    generator["accumulatedInterfaces"] = "export interface IPerson { name: string; }";

    generator["writeInterfacesToFile"]();

    expect(mockWriteFileSync).toHaveBeenCalledWith(
      "./output/IPerson.ts",
      "// Generated by multi-json-to-ts\n\nexport interface IPerson { name: string; }",
    );
  });

  it("should create a backup of the old file with a timestamp if backupOldFile is true", () => {
    const mockExistsSync = jest.spyOn(fs, "existsSync").mockReturnValue(true);
    const mockCopyFileSync = jest.spyOn(fs, "copyFileSync");
    const mockWriteFileSync = jest.spyOn(fs, "writeFileSync");

    const backupGenerator = new InterfaceGenerator("IPerson", "./output", true);
    backupGenerator["accumulatedInterfaces"] = "export interface IPerson { name: string; }";

    // Mock Date to control the timestamp
    const mockDate = new Date(2024, 1, 1, 12, 0, 0); // Feb 1, 2024, 12:00:00
    jest.spyOn(global, "Date").mockImplementation(() => mockDate);

    const timestamp = mockDate.toISOString().replace(/[-:.]/g, "_");

    backupGenerator["writeInterfacesToFile"]();

    expect(mockExistsSync).toHaveBeenCalledWith("./output/IPerson.ts");
    expect(mockCopyFileSync).toHaveBeenCalledWith(`./output/IPerson.ts`, `./output/IPerson.ts.${timestamp}.bak`);
    expect(mockWriteFileSync).toHaveBeenCalledWith(
      "./output/IPerson.ts",
      "// Generated by multi-json-to-ts\n\nexport interface IPerson { name: string; }",
    );
  });

  it("should correctly name nested interfaces", () => {
    const interfaceName = generator["getNestedInterfaceName"]("IPerson", "address");
    expect(interfaceName).toBe("IPerson_address");
  });

  it("should handle cases where multiple nested interfaces have the same name", () => {
    generator["interfaceNames"].add("IPerson_address");
    const interfaceName = generator["getNestedInterfaceName"]("IPerson", "address");
    expect(interfaceName).toBe("IPerson_address_1");
  });

  it("should generate the correct TypeScript interface for a given JSON variation", () => {
    const variation1 = {
      name: "John",
      age: 30,
      birthplace: {
        city: "New York",
        state: "NY",
      },
      stats: [{ year: 2020, goals: 10 }],
    };

    const variation2 = {
      name: "Sarah",
      age: 20,
      birthplace: {
        city: "Toronto",
        country: "Canada",
      },
      stats: [{ year: 2020, assists: 5 }],
    };

    generator.addJsonVariation(variation1);
    generator.addJsonVariation(variation2);

    generator.generateInterfaces();

    const expectedInterface = `export interface IPerson_birthplace {
  city: string;
  state?: string;
  country?: string;
}

export interface IPerson_stats {
  year: number;
  goals?: number;
  assists?: number;
}

export interface IPerson {
  name: string;
  age: number;
  birthplace: IPerson_birthplace;
  stats: IPerson_stats[];
}`;

    // Check the accumulated interface content
    expect(generator["accumulatedInterfaces"].trim()).toEqual(expectedInterface.trim());
  });
});
